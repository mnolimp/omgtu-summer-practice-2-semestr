#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

public static bool isSoftStopRequested = false;

#!csharp

public interface ICommand
{
    void Execute();
}

#!csharp

public class HardStop : ICommand
{
    private Thread stoppingThread;

    public HardStop(Thread stoppingThread)
    {
        this.stoppingThread = stoppingThread;
    }

    public void Execute()
    {
        if (stoppingThread != Thread.CurrentThread)
        {
            throw new Exception("HardStop cannot be executed in non-target thread");
        }
        stoppingThread.Interrupt();
    }
}

#!csharp

public class SoftStop : ICommand
{
    private BlockingCollection<ICommand> commandQueue;
    private Thread stoppingThread;

    public SoftStop(BlockingCollection<ICommand> commandQueue, Thread stoppingThread)
    {
        this.commandQueue = commandQueue;
        this.stoppingThread = stoppingThread;
    }

    public void Execute()
    {
        if (stoppingThread != Thread.CurrentThread)
        {
            throw new Exception("SoftStop cannot be executed in non-target thread");
        }

        if(isSoftStopRequested){
        while (commandQueue.Count > 0)
            {
                ICommand command = commandQueue.Take();
                command.Execute();
            }
        }
    }
}

#!csharp

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

#!csharp

public class Scheduler : IScheduler
{
    public BlockingCollection<ICommand> longCommandQueue = new BlockingCollection<ICommand>();
    
    public bool HasCommand(){
        if(longCommandQueue.Count > 0) return true;
        else return false;
    }

    public ICommand Select()
    {
        return longCommandQueue.Take();
    }

    public void Add(ICommand command){
        longCommandQueue.Add(command);
    }
}

#!csharp

public static class ExceptionHandler
{
    public static void Handle(Exception exception, ICommand command){
        Console.WriteLine("Exception " + exception + " caught while trying to execute next command: " + command.GetType().Name);
    }
}

#!csharp

public class ServerThread
{
    public BlockingCollection<ICommand> commandQueue = new BlockingCollection<ICommand>();

    public Thread mainThread;

    public Scheduler scheduler = new Scheduler();

    public ServerThread()
    {
        mainThread = new Thread(Run);

        mainThread.Start();
    }

    public void Run()
    {

        while ((commandQueue.Count > 0) && (!isSoftStopRequested))
        {
            ICommand command = commandQueue.Take();
            try
            {
                if(command is SoftStop){
                     isSoftStopRequested = true;
                     break;
                } else if (command is HardStop) break;
                command.Execute();
                
            }
            catch (Exception exception)
            {
                ExceptionHandler.Handle(exception, command);
            }
        }

        while (scheduler.HasCommand())
        {
            ICommand nextCommand = scheduler.Select();
            try
            {
                nextCommand.Execute();
            }
            catch (Exception exception)
            {
                ExceptionHandler.Handle(exception, nextCommand);
            }
        }
    }

    public void AddCommand(ICommand command)
    {
        commandQueue.Add(command);
    }
}

#!csharp

public class TestCommand : ICommand
{
    public void Execute()
    {
        Console.WriteLine("Server is doing smth...");
    }
}

#!csharp

public class NewTestCommand(int id) : ICommand
{

    int counter = 0;

    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
    }
}

#!csharp

public class LongTestCommand : ICommand
{
    public ServerThread serverThread;
    public int numberOfExecutions = 0, maxNumberOfExecutions;
    public NewTestCommand newTestCommand;

    public LongTestCommand(ServerThread serverThread, int maxNumberOfExecutions, NewTestCommand newTestCommand)
    {
        this.serverThread = serverThread;
        this.maxNumberOfExecutions = maxNumberOfExecutions;
        this.newTestCommand = newTestCommand;
    }

    public void Execute()
    {
        if(numberOfExecutions == maxNumberOfExecutions)
        {
            return;
        }
        newTestCommand.Execute();
        serverThread.scheduler.Add(this);
        numberOfExecutions++;
    }
}

#!csharp

ServerThread serverThread = new ServerThread();

for(int i = 1; i < 6; i++){
    serverThread.AddCommand(new LongTestCommand(serverThread, 3, new NewTestCommand(i)));
}

try
{
    serverThread.AddCommand(new HardStop(serverThread.mainThread));
}
catch(Exception exception)
{
    Console.WriteLine(exception.Message);
}

serverThread.mainThread.Join();
